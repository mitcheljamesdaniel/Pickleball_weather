[{"name": "app.py", "content": "#pickleball weather shiny\n\n#import api stuff\nfrom optparse import AmbiguousOptionError\nfrom turtle import setundobuffer\nimport requests\nimport json\n\n#import shiny stuff\nimport shiny\n\n#define weather class\n#each weather object encompasses the weather conditions for a given 3h time window\nclass weather: #class of objects that consist of a single entry (i.e. time window) returned by the API request\n    def __init__(self, json_data):\n        self.temp = int(json_data[\"main\"][\"temp\"])\n        self.speed = int(json_data[\"wind\"][\"speed\"])\n        self.precip = int(json_data[\"pop\"]*100)\n        self.feels_like = int(json_data[\"main\"][\"feels_like\"])\n        #self.datetime = json_data['dt_txt']\n        self.date, self.time = json_data['dt_txt'].split(' ')\n        self.print_date = True #true by default, but gets overwritten by the check_dates method before getting used\n        self.filtered_index = 0 #overwritten by check_dates method before getting used\n        self.suitable = False #false by default, but gets overwritten by the check_conditions method before getting used\n        self.day = True #overwritten by check_day method\n    \n    def check_conditions(self): #checks whether the conditions are suitable\n        if self.temp > min_temp and self.temp < max_temp and self.speed < max_speed and self.precip < max_precip:\n            self.suitable = True\n    \n    def check_day(self): #checks whether the time window is during the day (6:00 am to 11:00 pm)\n        self.day = self.time > \"05:59:00\" and self.time < \"22:59:00\"\n        return self.day\n    \n    def report_conditions(self):\n        if self.filtered_index == 0:\n            print(\"Suitable times to play outdoor pickleball in \" + geo_response.json()[0]['name'] + \", \" + geo_response.json()[0]['state'] + \", \" + geo_response.json()[0]['country'] + \"\\n\")\n        if self.print_date:\n            print(self.date)\n        #get the hour that the time window starts, and convert to int\n        h_mil = int(self.time[:-6])\n        #convert h from military time to standard time\n        if h_mil == 12 or h_mil == 24:\n            h = 12\n        else:\n            h = h_mil % 12\n        if h_mil < 12:\n            h_period = \" am\"\n        else:\n            h_period = \" pm\"\n        #get the end of the time window\n        h_t_mil = (h_mil + 3)\n        if h_t_mil == 12 or h_t_mil == 24:\n            h_t = 12\n        else:\n            h_t = h_t_mil % 12\n        if h_t_mil < 12 or h_t_mil == 24:\n            h_t_period = \" am\"\n        else:\n            h_t_period = \" pm\"\n        time_range = str(h) + \":00\" + h_period + \" to \" + str(h_t) + \":00\" + h_t_period\n        print(time_range)\n        #report the temperature\n        print(\"Temp: \" + str(self.temp) + u'\\N{DEGREE SIGN}' + \"F (feels like \" + str(self.feels_like) + u'\\N{DEGREE SIGN}' + \"F)\")\n        #report the wind speed\n        print(\"Wind speed: \" + str(self.speed) + \"mph\")\n        #report precipitation\n        print(\"Chance of precipidation: \" + str(self.precip) + \"%\\n\")\n    \n    def check_dates(self, filtered_index):\n        self.filtered_index = filtered_index\n        if filtered_index > 0:\n            self.print_date = self.date != filtered_list[filtered_index-1].date\n\n#define state abbrevation choices\nstates = [\"AL\", \"AK\", \"AZ\", \"AR\", \"AS\", \"CA\", \"CO\", \"CT\", \"DE\", \"DC\", \"FL\", \"GA\", \"GU\", \"HI\", \"ID\", \"IL\", \"IN\", \"IA\", \"KS\", \"KY\", \"LA\", \n          \"ME\", \"MD\", \"MA\", \"MI\", \"MN\", \"MS\", \"MO\", \"MT\", \"NE\", \"NV\", \"NH\", \"NJ\", \"NM\", \"NY\", \"NC\", \"ND\", \"MP\", \"OH\", \"OK\", \"OR\", \"PA\", \n          \"PR\", \"RI\", \"SC\", \"SD\", \"TN\", \"TX\", \"TT\", \"UT\", \"VT\", \"VA\", \"VI\", \"WA\", \"WV\", \"WI\", \"WY\"]\n\n#create the shiny app\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_text(\"city\", \"City:\", placeholder=\"Enter city name\"),\n            ui.input_selectize(\"state\", \"State:\", states)\n            ui.input_slider(\"temp_range\", \"Temperature range (F):\", value=(40, 90), min = 0, max = 110),\n            ui.input_slider(\"max_precip\", \"Max chance of precipitation (%):\", 0, 100, 30),\n            ui.input_numeric(\"max_speed\", \"Max wind speed (mph):\", 15)\n        ),\n        ui.panel_main(\n            ui.output_text(\"txt\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @reactive.Calc\n    def geo_parameters():\n        return {\n            \"q\": input.city + \",\" + input.state +  \",US\",\n            \"appid\": \"b0fb1574b0176f4025a21cfea6f99005\",\n            \"limit\": 1\n            }\n    @output\n    @render.text\n    def txt():\n        return f\"The location is {geo_parameters()['q']}\"\n\n\n\n\n\n\napp = App(ui=app_ui, server=server) \n\n\n\n####NOTE: need to tweak code to parse the input from the temp slider into min temp and max temp variables\n#do this outside of the weather class to avoid repeating the computation?\n\n\n#Indicate in UI somewhere that it's (currently) limited to cities in the US?", "type": "text"}]